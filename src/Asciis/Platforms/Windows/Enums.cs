namespace No8.Ascii.Platforms;

public static partial class Windows
{

    [Flags]
    public enum FormatMessageFlags
    {
        AllocateBuffer          = 0x0000_0100,
        IgnoreInserts           = 0x0000_0200,
        FromHmodule             = 0x0000_0800,
        FromSystem              = 0x0000_1000,
        ArgumentArray           = 0x0000_2000,
        ErrorInsufficientBuffer = 0x0000_007A
    }

    public enum StandardHandle
    {
        Input  = -10,
        Output = -11,
        Error  = -12
    }

    // Enumerated type for the control messages sent to the handler routine
    public enum CtrlTypes : uint
    {
        CtrlCEvent        = 0,
        CtrlBreakEvent    = 1,
        CtrlCloseEvent    = 2,
        CtrlLogoffEvent   = 5,
        CtrlShutdownEvent = 6
    }

    public enum EventType : ushort
    {
        Key              = 0x01,
        Mouse            = 0x02,
        WindowBufferSize = 0x04,
        Menu             = 0x08,
        Focus            = 0x10,
    }

    [Flags]
    public enum MouseEventFlags : uint
    {
        MouseMoved             = 0x01,
        DoubleClick            = 0x02,
        MouseWheeled           = 0x04,
        MouseHorizontalWheeled = 0x08
    }

    [Flags]
    public enum ConsoleInputModes : uint
    {
        /// <summary>
        /// CTRL+C is processed by the system and is not placed in the input buffer.
        /// If the input buffer is being read by ReadFile or ReadConsole, other control
        /// keys are processed by the system and are not returned in the ReadFile or
        /// ReadConsole buffer.
        /// If the ENABLE_LINE_INPUT mode is also enabled, backspace, carriage return,
        /// and line feed characters are handled by the system.
        /// </summary>
        EnableProcessedInput = 0x0001,

        /// <summary>
        /// The ReadFile or ReadConsole function returns only when a carriage return character
        /// is read. If this mode is disabled, the functions return when one or more characters
        /// are available.
        /// </summary>
        EnableLineInput = 0x0002,

        /// <summary>
        /// Characters read by the ReadFile or ReadConsole function are written to the active
        /// screen buffer as they are typed into the console. This mode can be used only if the
        /// ENABLE_LINE_INPUT mode is also enabled.
        /// </summary>
        EnableEchoInput = 0x0004,

        /// <summary>
        /// User interactions that change the size of the console screen buffer are reported
        /// in the console's input buffer. Information about these events can be read from
        /// the input buffer by applications using the ReadConsoleInput function, but not by
        /// those using ReadFile or ReadConsole.
        /// </summary>
        EnableWindowInput = 0x0008,

        /// <summary>
        /// If the mouse pointer is within the borders of the console window and the window has
        /// the keyboard focus, mouse events generated by mouse movement and button presses are
        /// placed in the input buffer.
        /// These events are discarded by ReadFile or ReadConsole, even when this mode is enabled.
        /// </summary>
        EnableMouseInput = 0x0010,

        /// <summary>
        /// When enabled, text entered in a console window will be inserted at the current cursor
        /// location and all text following that location will not be overwritten. When disabled,
        /// all following text will be overwritten.
        /// </summary>
        EnableInsertMode = 0x0020,

        /// <summary>
        /// This flag enables the user to use the mouse to select and edit text. To enable this
        /// mode, use ENABLE_QUICK_EDIT_MODE | ENABLE_EXTENDED_FLAGS. To disable this mode, use
        /// ENABLE_EXTENDED_FLAGS without this flag.
        /// </summary>
        EnableQuickEditMode = 0x0040,

        /// <summary>
        /// 
        /// </summary>
        EnableExtendedFlags        = 0x0080,

        /// <summary>
        /// 
        /// </summary>
        EnableAutoPosition         = 0x0100,

        /// <summary>
        /// Setting this flag directs the Virtual Terminal processing engine to convert user input
        /// received by the console window into Console Virtual Terminal Sequences that can be
        /// retrieved by a supporting application through WriteFile or WriteConsole functions.
        ///
        /// The typical usage of this flag is intended in conjunction with ENABLE_VIRTUAL_TERMINAL_PROCESSING
        /// on the output handle to connect to an application that communicates exclusively via
        /// virtual terminal sequences.
        /// </summary>
        EnableVirtualTerminalInput = 0x0200
    }

    [Flags]
    public enum ConsoleOutputModes : uint
    {
        /// <summary>
        /// Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or
        /// ReadConsole function are parsed for ASCII control sequences, and the correct action is
        /// performed. Backspace, tab, bell, carriage return, and line feed characters are processed.
        /// </summary>
        EnableProcessedOutput = 0x0001,

        /// <summary>
        /// When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the
        /// cursor moves to the beginning of the next row when it reaches the end of the current row.
        /// This causes the rows displayed in the console window to scroll up automatically when the
        /// cursor advances beyond the last row in the window.
        /// It also causes the contents of the console screen buffer to scroll up (../discarding the
        /// top row of the console screen buffer) when the cursor advances beyond the last row in the
        /// console screen buffer.
        /// If this mode is disabled, the last character in the row is overwritten with any subsequent characters.
        /// </summary>
        EnableWrapAtEolOutput = 0x0002,

        /// <summary>
        /// When writing with WriteFile or WriteConsole, characters are parsed for VT100 and similar
        /// control character sequences that control cursor movement, color/font mode, and other
        /// operations that can also be performed via the existing Console APIs. For more information,
        /// see Console Virtual Terminal Sequences.
        /// </summary>
        EnableVirtualTerminalProcessing = 0x0004,

        /// <summary>
        /// When writing with WriteFile or WriteConsole, this adds an additional state to end-of-line
        /// wrapping that can delay the cursor move and buffer scroll operations.
        ///
        /// Normally when ENABLE_WRAP_AT_EOL_OUTPUT is set and text reaches the end of the line, the
        /// cursor will immediately move to the next line and the contents of the buffer will scroll
        /// up by one line. In contrast with this flag set, the scroll operation and cursor move is
        /// delayed until the next character arrives. The written character will be printed in the
        /// final position on the line and the cursor will remain above this character as if
        /// ENABLE_WRAP_AT_EOL_OUTPUT was off, but the next printable character will be printed as
        /// if ENABLE_WRAP_AT_EOL_OUTPUT is on. No overwrite will occur. Specifically, the cursor
        /// quickly advances down to the following line, a scroll is performed if necessary, the
        /// character is printed, and the cursor advances one more position.
        ///
        /// The typical usage of this flag is intended in conjunction with setting
        /// ENABLE_VIRTUAL_TERMINAL_PROCESSING to better emulate a terminal emulator where writing
        /// the final character on the screen (../in the bottom right corner) without triggering
        /// an immediate scroll is the desired behavior.
        /// </summary>
        DisableNewlineAutoReturn        = 0x0008,

        /// <summary>
        /// The APIs for writing character attributes including WriteConsoleOutput and
        /// WriteConsoleOutputAttribute allow the usage of flags from character attributes to adjust
        /// the color of the foreground and background of text. Additionally, a range of DBCS flags
        /// was specified with the COMMON_LVB prefix. Historically, these flags only functioned
        /// in DBCS code pages for Chinese, Japanese, and Korean languages.
        ///
        /// With exception of the leading byte and trailing byte flags, the remaining flags describing
        /// line drawing and reverse video(../swap foreground and background colors) can be useful for
        /// other languages to emphasize portions of output.
        ///
        /// Setting this console mode flag will allow these attributes to be used in every code
        /// page on every language.
        ///
        /// It is off by default to maintain compatibility with known applications that have historically
        /// taken advantage of the console ignoring these flags on non-CJK machines to store bits
        /// in these fields for their own purposes or by accident.
        ///
        /// Note that using the ENABLE_VIRTUAL_TERMINAL_PROCESSING mode can result in LVB grid and
        /// reverse video flags being set while this flag is still off if the attached application
        /// requests underlining or inverse video via Console Virtual Terminal Sequences.
        /// </summary>
        EnableLvbGridWorldwide          = 0x0010
    }

    [Flags]
    public enum ConsoleDisplayMode : uint
    {
        Default = 0x0000,
        FullScreen = 0x0001,
        FullScreenHardware = 0x0002
    }
    
    [Flags]
    public enum CharacterAttributes : ushort
    {
        FgBlack       = 0x0000,
        FgDarkBlue    = 0x0001,
        FgDarkGreen   = 0x0002,
        FgDarkCyan    = 0x0003,
        FgDarkRed     = 0x0004,
        FgDarkMagenta = 0x0005,
        FgDarkYellow  = 0x0006,
        FgGrey        = 0x0007,
        FgDarkGrey    = 0x0008,
        FgBlue        = 0x0009,
        FgGreen       = 0x000A,
        FgCyan        = 0x000B,
        FgRed         = 0x000C,
        FgMagenta     = 0x000D,
        FgYellow      = 0x000E,
        FgWhite       = 0x000F,

        BgBlack       = 0x0000,
        BgDarkBlue    = 0x0010,
        BgDarkGreen   = 0x0020,
        BgDarkCyan    = 0x0030,
        BgDarkRed     = 0x0040,
        BgDarkMagenta = 0x0050,
        BgDarkYellow  = 0x0060,
        BgGrey        = 0x0070,
        BgDarkGrey    = 0x0080,
        BgBlue        = 0x0090,
        BgGreen       = 0x00A0,
        BgCyan        = 0x00B0,
        BgRed         = 0x00C0,
        BgMagenta     = 0x00D0,
        BgYellow      = 0x00E0,
        BgWhite       = 0x00F0,

        LeadingByte    = 0x0100,
        TrailingByte   = 0x0200,
        GridHorizontal = 0x0400,
        GridLVertical  = 0x0800,
        GridRVertical  = 0x1000,
        ReverseVideo   = 0x4000,
        Underscore     = 0x8000
    }

    public enum PixelType
    {
        UpperHalfBlock = 0x2580,
        LowerHalfBlock = 0x2584,
        Solid          = 0x2588,
        LeftHalfBlock  = 0x258C,
        RightHalfBlock = 0x2590,
        LightShade     = 0x2591,
        MediumShade    = 0x2592,
        DarkShade      = 0x2593,
        SolidSquare    = 0x25A0,
        SolidRectangle = 0x25AC,
        TriangleUp     = 0x25B2,
        TriangleRight  = 0x25BA,
        TriangleDown   = 0x25BC,
        TriangleLeft   = 0x25C4, // ◄
        Lazenge        = 0x25CA, // ◊
    }

    [Flags]
    public enum PseudoConsoleFlags : ulong
    {
        PseudoconsoleInheritCursor = 1
    }

    [Flags]
    public enum DesiredAccess : uint
    {
        GenericRead  = 0x8000_0000,
        GenericWrite = 0x4000_0000,
        ReadWrite    = GenericRead | GenericWrite
    }
    
    [Flags]
    public enum ShareMode : uint
    {
        FileShareRead  = 1,
        FileShareWrite = 2
    }


    public enum FontWeight
    {
        Dontcare   = 0,
        Thin       = 100,
        Extralight = 200,
        Light      = 300,
        Normal     = 400,
        Medium     = 500,
        Semibold   = 600,
        Bold       = 700,
        Extrabold  = 800,
        Heavy      = 900
    }

    public enum FontCharSet : byte
    {
        AnsiCharset        = 0,
        DefaultCharset     = 1,
        SymbolCharset      = 2,
        ShiftjisCharset    = 128,
        HangeulCharset     = 129,
        HangulCharset      = 129,
        Gb2312Charset      = 134,
        Chinesebig5Charset = 136,
        OemCharset         = 255,
        JohabCharset       = 130,
        HebrewCharset      = 177,
        ArabicCharset      = 178,
        GreekCharset       = 161,
        TurkishCharset     = 162,
        VietnameseCharset  = 163,
        ThaiCharset        = 222,
        EasteuropeCharset  = 238,
        RussianCharset     = 204,
        MacCharset         = 77,
        BalticCharset      = 186
    }

    public enum FontPrecision : byte
    {
        OutDefaultPrecis       = 0,
        OutStringPrecis        = 1,
        OutCharacterPrecis     = 2,
        OutStrokePrecis        = 3,
        OutTtPrecis            = 4,
        OutDevicePrecis        = 5,
        OutRasterPrecis        = 6,
        OutTtOnlyPrecis        = 7,
        OutOutlinePrecis       = 8,
        OutScreenOutlinePrecis = 9,
        OutPsOnlyPrecis        = 10
    }

    [Flags]
    public enum FontClipPrecision : byte
    {
        ClipDefaultPrecis   = 0x00,
        ClipCharacterPrecis = 0x01,
        ClipStrokePrecis    = 0x02,
        ClipMask            = 0x0f,
        ClipLhAngles        = 0x10,
        ClipTtAlways        = 0x20,
        ClipDfaDisable      = 0x40,
        ClipEmbedded        = 0x80
    }

    public enum FontQuality : byte
    {
        DefaultQuality          = 0,
        DraftQuality            = 1,
        ProofQuality            = 2,
        NonantialiasedQuality   = 3,
        AntialiasedQuality      = 4,
        CleartypeQuality        = 5,
        CleartypeNaturalQuality = 6
    }

    [Flags]
    public enum FontPitchAndFamily : byte
    {
        DefaultPitch  = 0x00,
        FixedPitch    = 0x01,
        VariablePitch = 0x02,

        FfDontcare   = 0x00,
        FfRoman      = 0x10,
        FfSwiss      = 0x20,
        FfModern     = 0x30,
        FfScript     = 0x40,
        FfDecorative = 0x50
    }

    [Flags]
    public enum ControlKeyState : uint
    {
        RightAltPressed  = 0x001,
        LeftAltPressed   = 0x002,
        RightCtrlPressed = 0x004,
        LeftCtrlPressed  = 0x008,
        ShiftPressed     = 0x010,
        NumlockOn        = 0x020,
        ScrolllockOn     = 0x040,
        CapslockOn       = 0x080,
        EnhancedKey      = 0x100,
    }


    [Flags]
    public enum MouseButtonState : uint
    {
        FromLeft1StButtonPressed = 0x0001, // The leftmost mouse button.
        RightmostButtonPressed   = 0x0002, // The rightmost mouse button.
        FromLeft2NdButtonPressed = 0x0004, // The second button from the left.
        FromLeft3RdButtonPressed = 0x0008, // The third button from the left.
        FromLeft4ThButtonPressed = 0x0010, // The fourth button from the left.
    }

    [Flags]
    public enum ConsoleSelectionFlags : uint
    {
        ConsoleNoSelection         = 0x0000, // No selection
        ConsoleSelectionInProgress = 0x0001, // Selection has begun
        ConsoleSelectionNotEmpty   = 0x0002, // Selection rectangle is not empty
        ConsoleMouseSelection      = 0x0004, // Selecting with the mouse
        ConsoleMouseDown           = 0x0008, // Mouse is down
    }

    public enum ConsoleHistoryFlags : uint
    {
        HistoryNoDupFlag = 0x01
    }
    
    /// <summary>
    /// Cursors Visibility that are displayed
    /// 
    /// Hexa value are set as 0xAABBCCDD where :
    ///
    ///     AA stand for the TERMINFO DECSUSR parameter value to be used under Linux & MacOS
    ///     BB stand for the NCurses curs_set parameter value to be used under Linux & MacOS
    ///     CC stand for the CONSOLE_CURSOR_INFO.bVisible parameter value to be used under Windows
    ///     DD stand for the CONSOLE_CURSOR_INFO.dwSize parameter value to be used under Windows
    ///
    /// </summary>
    internal enum CursorVisibility
    {
        /// <summary>
        ///	Cursor caret has default
        /// </summary>
        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref="Underscore"/>. This default directly depends of the XTerm user configuration settings so it could be Block, I-Beam, Underline with possible blinking.</remarks>
        Default = 0x00010119,

        /// <summary>
        ///	Cursor caret is hidden
        /// </summary>
        Invisible = 0x03000019,

        /// <summary>
        ///	Cursor caret is normally shown as a blinking underline bar _
        /// </summary>
        Underline = 0x03010119,

        /// <summary>
        ///	Cursor caret is normally shown as a underline bar _
        /// </summary>
        /// <remarks>Under Windows, this is equivalent to <see ref="UnderscoreBlinking"/></remarks>
        UnderlineFix = 0x04010119,

        /// <summary>
        ///	Cursor caret is displayed a blinking vertical bar |
        /// </summary>
        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref="Underscore"/></remarks>
        Vertical = 0x05010119,

        /// <summary>
        ///	Cursor caret is displayed a blinking vertical bar |
        /// </summary>
        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref="Underscore"/></remarks>
        VerticalFix = 0x06010119,

        /// <summary>
        ///	Cursor caret is displayed as a blinking block ▉
        /// </summary>
        Box = 0x01020164,

        /// <summary>
        ///	Cursor caret is displayed a block ▉
        /// </summary>
        /// <remarks>Works under Xterm-like terminal otherwise this is equivalent to <see ref="Block"/></remarks>
        BoxFix = 0x02020164
    }
}